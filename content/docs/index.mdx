---
title: Introduction
description: "Omora Labs Docs provides a set of reusable components and blocks for building composable, modern finance analytics. Works with modern data stacks and analytics tools."
---

You know how most finance departments work: the accounting team runs the books on the traditional ERP. You download all the data into your spreadsheet. Then grab the numbers from file `budget_v3_approved.xlsx`. Now you just need to run the `budget vs actuals` alongside the board deck and the SaaS metrics. The CEO just asked about it. The investors are waiting.

This approach works well until you want to scale, add new business units or have to handle multiple entities with different currencies. The solution looks bright and shiny: implement a more powerful ERP that runs all of this out of box. Except that they don't integrate with your CRM, so you don't really know how many new customers you added last month. Nor they can run a cash runway calculation on a set of inputs. Not to speak of 7 months implementations and 12-month running contracts.

This is what Omora Labs finance analytics components and blocks aim to solve. It is built around the following principles:

- Open Code: All code, components, and blocks are fully open source.
- Composition: Each block is predictable, reusable, and built from primitives that are explicitly defined first.
- Single Source of Truth: All components and blocks are designed to read directly from your existing data warehouse.
- Data Portability: Built on open, file-based data formats and transparent transformations, so your data and logic remain portable.
- Only Best Stack: Stack composed of blazing fast, best in class open source code and frameworks.
- AI Ready: The codebase is structured, readable, and consistent, making it easy for AI tools to understand and work with.

## Open Code

All code, components, and blocks are fully open source, giving you complete visibility into how everything works. Because the code is open, you can adapt it to your organization's needs, extend it for new use cases, or strip it down to the essentials. You own the implementation and can evolve it as your data stack and business mature.

## Composition

Composable finance is built on (yes, you guessed it) **composability**: small, well-defined components are assembled into higher-level blocks. Each block is predictable, reusable, and built from primitives that are explicitly defined first.

This approach mirrors modern software architecture and avoids one-off dashboards or tightly coupled logic. You can swap components, recombine blocks, or create new ones without breaking the system.

## Single Source of Truth

All components and blocks are designed to read directly from your existing data warehouse. Metrics, time-windows, and dimensions live in one place, not duplicated across tools or dashboards.

This ensures consistency across teams and use cases, reduces reconciliation work, and prevents metric drift. Finance, Ops, and leadership all see the same numbers. **Computed once, reused everywhere**.

## No Vendor Lock In

The architecture is intentionally designed around data portability, with a clear separation between data models, business logic, and presentation. Core transformations live in open, inspectable code and file-based data formats, not inside proprietary BI or warehouse layers.

You can evolve your stack over time - from [Snowflake](https://www.snowflake.com) to [BigQuery](https://console.cloud.google.com/bigquery), from [Looker](https://lookerstudio.google.com/) to [Hex](https://hex.tech/) - while keeping your components and blocks intact. Your data model stays portable and future-proof. Your data stays yours.

## Only Best Stack

The components and blocks are built exclusively on best-in-class, open-source technologies chosen for performance, reliability, and long-term viability. Every framework and library is selected because it is widely adopted, well-maintained, and proven in production environments.

This results in a fast, modern stack with no experimental dependencies or unnecessary layers. You get performance by default, transparency by design, and a foundation that can scale with both data volume and organisational complexity.

## AI-Ready

The codebase is structured, readable, and consistent, making it easy for AI tools to understand and work with. Components follow clear patterns, which LLMs can reliably parse and reason about.

This enables AI-assisted development: suggesting improvements, generating new components, or adapting existing ones to new requirements.
